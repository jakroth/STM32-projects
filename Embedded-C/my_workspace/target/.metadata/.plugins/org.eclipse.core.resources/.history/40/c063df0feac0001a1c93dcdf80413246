/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>		// include this to use standardised type, e.g. uint32_t; avoids different implementations of int on different architectures

int main(void)
{
	// pointer to hold the address of the register of the clock for all the GPIO pins (among other things)
	// 32-bit type to store a 32-bit memory address
	// the address is equal to the base register for RCC (clock) related stuff, plus the offset for the AHB1 (bus) peripherals, which includes the GPIO pins
	// need to set the value of individual bits of this memory address, to turn on the clock for the correct GPIO pins (it's bit 3 for GPIO D)
	// so need a bit | mask to set bits
	// sets the clock on for all 16 of the GPIO D pins
	uint32_t *pClkCtrlReg = (uint32_t*) (0x40023800 + 0x30);

	// pointer to hold the address of the modes for the GPIO D pins
	// the address is equal to the GPIO D base register address + the offset for the mode registers (0x00 in this case)
	// need to set the value of 2 bits of this memory address, to put GPIO D12 into output mode (bits 25,24 in this case)
	// so need a bit | mask to set these bits to "01"
	uint32_t *pPortDModeReg = (uint32_t*) (0x40020c00 + 0x00);

	// pointer to hold the address of the output data for the GPIO D pins
	// the address is equal to the GPIO D base register address + the offset for the output data registers (0x14 in this case)
	// need to set the value of 1 bit of this memory address, to change the output of GPIO D12 (bit 12 in this case)
	// so need a bit | mask to set this bit to "1" for high (on, 3.3V) and "0" for low (off, ground or 0V)
	uint32_t *pPortDOutReg = (uint32_t*) (0x40020c00 + 0x14);

	//1. ENABLE the CLOCK for GPIO D peripheral in AHB1 ENR, by setting bit 3 to "1"
	// need to do this without changing the value of any of the other bits, so use a bitwise OR "|" operation, using a bit mask
	// bit mask should be "1" for bit 3 and "0" for all other 31 bits, so 00000000 00000000 00000000 00001000; in hex this is 0x00000008
	uint32_t temp = *pClkCtrlReg; 	// read, store the current bit values of the peripheral clock register in temp
	temp = temp | 0x08;				// modify, perform a bitwise OR on temp, which leaves all bits as they are, except bit 3, which is set to "1" (regardless of what it was before)
	*pClkCtrlReg = temp;			// write, store the modified bit values back in the peripheral clock register

	//could also write this in shorthand notation, which does the above steps
	//*pClkCtrlReg |= 0x08;


	//2. SET the MODE for GPIO D12 peripheral, by setting bit 25,24 to "01"
	// first, clear the bits (set them to 0);
	// need to use an & bit mask, which leaves bits as they are, but sets chosen bits (25,24) to "0"
	// the bit mask is 11111100 11111111 11111111 11111111; in hex this is 0xFCFFFFFF
	*pPortDModeReg &= 0xFCFFFFFF;

	// second, need to set bits 25,24 to "01"
	// need to use an | bit mask, which leaves bits as they are but sets chosen bits (25,24) to "10"
	// note: if you don't clear first, there is no guarantee what bit 25 is at this point
	// the bit mask is 00000001 00000000 00000000 00000000; in hex this is 0x01000000




	for(;;);
}
