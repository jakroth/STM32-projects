/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

void delay (void);

int main(void)
{
	uint32_t volatile * const pABH1_Clk_Reg 	= (uint32_t*)0x40023830;
	uint32_t volatile * const pGPIO_D_Mode_Reg 	= (uint32_t*)0x40020C00;
	uint32_t volatile * const pGPIO_D_Pull_Reg 	= (uint32_t*)0x40020C0C;
	uint32_t volatile * const pGPIO_D_In_Reg 	= (uint32_t*)0x40020C10;
	uint32_t volatile * const pGPIO_D_Out_Reg 	= (uint32_t*)0x40020C14;

	//using pins PD 0,1,2,3 for columns (input)
	//using pins PD 8,9,10,11 for rows (output)

	//1. Set clock on for the GPIO_D pins (bit 3 = "1")
	*pABH1_Clk_Reg |= (1 << 3);

	//2. Set mode for all column pins to input (it's the default state, but don't assume they are already in that state)
	// at the same time, set all row pins to 0 initially, in preparation for next step
	// (bits 0-7 = "0", bits 16-23 = "0"), bit mask to use is 11111111 00000000 11111111 00000000 = 0xFF00FF00
	*pGPIO_D_Mode_Reg &= 0xFF00FF00;

	//3. Set mode for all row pins to output
	// (bits 16-23 = "01"), bit mask is 00000000 01010101 00000000 00000000 = 0x00550000 = (85 << 16);
	*pGPIO_D_Mode_Reg |= (85 << 16);

	//4. Give all column pins a pull up connection. This sets them all to high instead of floating, through a highly resisted (20k) connection to a 3.3v source
	// need to zero them first, with mask 11111111 11111111 11111111 00000000 = 0xFFFFFF00 = ~(255 << 0)
	*pGPIO_D_Pull_Reg &= ~(255 << 0);
	// then set bits 0-7 to "01", with mask 00000000 00000000 00000000 01010101 = 0x00000055 = (85 << 0)
	*pGPIO_D_Pull_Reg |= (85 << 0);

	//5. now a while loop which tests which button is pressed
	// needs to set each row to low, one at a time, and see if any corresponding columns become low, so see which matrix button is pressed

	// 	a. set all rows high to start
	//	bit mask is 00000000 00000000 00001111 00000000 = 0x00000F00 = (15 << 8)
	*pGPIO_D_Out_Reg |= (15 << 8);

	//	b. set the first row low, keep all others high
	// 	bit mask will be 11111111 11111111 11111110 11111111 = 0xFFFFFEFF = ~(1 << 8)
	*pGPIO_D_Out_Reg &= ~(1 << 8);

	while(1){
		//	c. check each column (bits 0-3)
		if((*pGPIO_D_In_Reg & (1 << 0)) == 0){
			printf("\nbutton at r1, c1 pressed");
		}
	}
}
